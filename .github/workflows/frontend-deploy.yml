name: Deploy Frontend

on:
  workflow_call:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: string
      image_tag:
        description: "Docker image tag to deploy"
        required: true
        type: string
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - prod
      image_tag:
        description: "Docker image tag to deploy"
        required: true
        default: "dev"
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}-frontend

jobs:
  deploy:
    runs-on: ubuntu-24.04
    environment: ${{ inputs.environment }}

    permissions:
      contents: read
      packages: read
      deployments: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ inputs.environment }}',
              description: 'Deploying frontend to ${{ inputs.environment }}',
              auto_merge: false,
              required_contexts: []
            });

            core.setOutput('deployment_id', deployment.data.id);
            return deployment.data.id;

      - name: Set deployment status to in progress
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.deployment_id }}',
              state: 'in_progress',
              description: 'Deployment started'
            });

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.13.3"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.28.4"

      - name: Configure Kubernetes context
        run: |
          # Debug: Check if KUBECONFIG_DATA is set
          if [ -z "${{ secrets.KUBECONFIG_DATA }}" ]; then
            echo "ERROR: KUBECONFIG_DATA secret is empty or not set!"
            echo "Please ensure KUBECONFIG_DATA is configured in the GitHub environment: ${{ inputs.environment }}"
            exit 1
          fi

          # Debug: Check secret length and first few characters
          SECRET_LENGTH=$(echo "${{ secrets.KUBECONFIG_DATA }}" | wc -c)
          echo "Secret length: $SECRET_LENGTH characters"
          echo "First 50 characters: $(echo "${{ secrets.KUBECONFIG_DATA }}" | head -c 50)"

          # Try to decode with better error handling
          if ! echo "${{ secrets.KUBECONFIG_DATA }}" | base64 -d > ~/.kube/config 2>/tmp/base64_error; then
            echo "ERROR: Failed to decode base64 secret"
            echo "Base64 error output:"
            cat /tmp/base64_error
            echo "This usually means the secret is not properly base64 encoded"
            exit 1
          fi

          chmod 600 ~/.kube/config

          # Debug: Check if config file was created
          if [ ! -f ~/.kube/config ]; then
            echo "ERROR: Failed to create ~/.kube/config"
            exit 1
          fi

          echo "Kubernetes config file created successfully"
          echo "Config file size: $(wc -c < ~/.kube/config) bytes"

          # Verify connection
          kubectl cluster-info
          kubectl get nodes

      - name: Determine deployment configuration
        id: config
        run: |
          ENVIRONMENT="${{ inputs.environment }}"
          IMAGE_TAG="${{ inputs.image_tag }}"
          IMAGE_REPO="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          # Sanitize branch name for Kubernetes resources
          BRANCH_NAME="${{ github.ref_name }}"
          SANITIZED_BRANCH=$(echo "${BRANCH_NAME}" | sed 's/[^a-zA-Z0-9._-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')

          # Set configuration based on environment
          case "${ENVIRONMENT}" in
            "prod")
              VALUES_FILE="values-prod.yaml"
              NAMESPACE="production"
              ENVIRONMENT_URL="https://coregame.de"
              ;;
            "dev")
              VALUES_FILE="values-dev.yaml"
              NAMESPACE="development"
              ENVIRONMENT_URL="https://dev.coregame.de"
              ;;
            *)
              echo "Unknown environment: ${ENVIRONMENT}"
              exit 1
              ;;
          esac

          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "branch=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "sanitized_branch=${SANITIZED_BRANCH}" >> $GITHUB_OUTPUT
          echo "values_file=${VALUES_FILE}" >> $GITHUB_OUTPUT
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_repo=${IMAGE_REPO}" >> $GITHUB_OUTPUT
          echo "release_name=frontend-${SANITIZED_BRANCH}" >> $GITHUB_OUTPUT
          echo "environment_url=${ENVIRONMENT_URL}" >> $GITHUB_OUTPUT

          echo "Deployment Configuration:"
          echo "- Environment: ${ENVIRONMENT}"
          echo "- Branch: ${BRANCH_NAME} (sanitized: ${SANITIZED_BRANCH})"
          echo "- Values file: ${VALUES_FILE}"
          echo "- Namespace: ${NAMESPACE}"
          echo "- Image tag: ${IMAGE_TAG}"
          echo "- Image repo: ${IMAGE_REPO}"
          echo "- Release name: frontend-${SANITIZED_BRANCH}"
          echo "- Environment URL: ${ENVIRONMENT_URL}"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ steps.config.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create image pull secret
        run: |
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=${{ github.actor }}@users.noreply.github.com \
            --namespace=${{ steps.config.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Validate Helm chart
        run: |
          cd frontend/helm
          helm lint . --values ${{ steps.config.outputs.values_file }}
          helm template ${{ steps.config.outputs.release_name }} . \
            --namespace ${{ steps.config.outputs.namespace }} \
            --values ${{ steps.config.outputs.values_file }} \
            --set image.tag=${{ steps.config.outputs.image_tag }} \
            --set image.repository=${{ steps.config.outputs.image_repo }} \
            --set secrets.NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}" \
            --set env.CLIENT_ID_GITHUB="${{ vars.CLIENT_ID_GITHUB }}" \
            --set secrets.CLIENT_SECRET_GITHUB="${{ secrets.CLIENT_SECRET_GITHUB }}" \
            --set secrets.BACKEND_SECRET="${{ secrets.BACKEND_SECRET }}" \
            --set env.NEXT_PUBLIC_FORTY_TWO_CLIENT_ID="${{ vars.NEXT_PUBLIC_FORTY_TWO_CLIENT_ID }}" \
            --set secrets.FORTY_TWO_CLIENT_SECRET="${{ secrets.FORTY_TWO_CLIENT_SECRET }}" \
            --validate

      - name: Deploy with Helm
        run: |
          cd frontend/helm

          echo "Deploying frontend to ${{ steps.config.outputs.environment }} environment..."
          echo "Using values file: ${{ steps.config.outputs.values_file }}"
          echo "Image: ${{ steps.config.outputs.image_repo }}:${{ steps.config.outputs.image_tag }}"

          helm upgrade --install \
            ${{ steps.config.outputs.release_name }} \
            . \
            --namespace ${{ steps.config.outputs.namespace }} \
            --values ${{ steps.config.outputs.values_file }} \
            --set image.tag=${{ steps.config.outputs.image_tag }} \
            --set image.repository=${{ steps.config.outputs.image_repo }} \
            --set secrets.NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}" \
            --set env.CLIENT_ID_GITHUB="${{ vars.CLIENT_ID_GITHUB }}" \
            --set secrets.CLIENT_SECRET_GITHUB="${{ secrets.CLIENT_SECRET_GITHUB }}" \
            --set secrets.BACKEND_SECRET="${{ secrets.BACKEND_SECRET }}" \
            --set env.NEXT_PUBLIC_FORTY_TWO_CLIENT_ID="${{ vars.NEXT_PUBLIC_FORTY_TWO_CLIENT_ID }}" \
            --set secrets.FORTY_TWO_CLIENT_SECRET="${{ secrets.FORTY_TWO_CLIENT_SECRET }}" \
            --wait \
            --timeout=10m \
            --atomic \
            --history-max=5

      - name: Verify deployment
        run: |
          echo "Verifying deployment in namespace: ${{ steps.config.outputs.namespace }}"

          # Wait for rollout to complete
          kubectl rollout status deployment/${{ steps.config.outputs.release_name }} -n ${{ steps.config.outputs.namespace }} --timeout=300s

          # Show deployment status
          kubectl get pods -n ${{ steps.config.outputs.namespace }} -l app.kubernetes.io/name=frontend
          kubectl get services -n ${{ steps.config.outputs.namespace }} -l app.kubernetes.io/name=frontend
          kubectl get ingress -n ${{ steps.config.outputs.namespace }} -l app.kubernetes.io/name=frontend

          # Show Helm release status
          helm status ${{ steps.config.outputs.release_name }} -n ${{ steps.config.outputs.namespace }}

      - name: Set deployment status to success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.deployment_id }}',
              state: 'success',
              description: 'Deployment completed successfully',
              environment_url: '${{ steps.config.outputs.environment_url }}'
            });

      - name: Set deployment status to failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.deployment_id }}',
              state: 'failure',
              description: 'Deployment failed'
            });

      - name: Deployment summary
        run: |
          echo "## Frontend Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Successfully deployed frontend to ${{ steps.config.outputs.environment }} environment**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ steps.config.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ steps.config.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace:** ${{ steps.config.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release name:** ${{ steps.config.outputs.release_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Values file:** ${{ steps.config.outputs.values_file }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ steps.config.outputs.image_repo }}:${{ steps.config.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment URL:** ${{ steps.config.outputs.environment_url }}" >> $GITHUB_STEP_SUMMARY
